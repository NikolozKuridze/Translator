using MediatR;
using Microsoft.EntityFrameworkCore;
using Translator.Application.Contracts;
using Translator.Application.Exceptions;
using Translator.Domain.Entities;
using Translator.Infrastructure.Database.Postgres.Repository;
using Translator.Infrastructure.Database.Redis.CacheServices;
using TranslationEntity = Translator.Domain.Entities.Translation;
using LanguageEntity = Translator.Domain.Entities.Language;

namespace Translator.Application.Features.Values.Commands;

public class AddTranslationsToAllValues
{
    public record Command(
        string LanguageCode
    ) : IRequest;


    public class Handler : IRequestHandler<Command>
    {
        private readonly IRepository<LanguageEntity> _languageEntityRepository;
        private readonly IRepository<TranslationEntity> _translationRepository;
        private readonly ValueCacheService _valueCacheService;
        private readonly IRepository<Value> _valueRepository;
        private readonly IRepository<User> _userRepository;
        private readonly ICurrentUserService _currentUserService;

        public Handler(
            IRepository<Value> valueRepository,
            IRepository<TranslationEntity> translationRepository,
            IRepository<LanguageEntity> languageEntityRepository,
            ValueCacheService valueCacheService,
            IRepository<User> userRepository, ICurrentUserService currentUserService)
        {
            _valueRepository = valueRepository;
            _translationRepository = translationRepository;
            _languageEntityRepository = languageEntityRepository;
            _valueCacheService = valueCacheService;
            _userRepository = userRepository;
            _currentUserService = currentUserService;
        }

        public async Task Handle(Command request, CancellationToken cancellationToken)
        {
            var userId = _currentUserService.GetCurrentUserId();
            if (!userId.HasValue)
                throw new UnauthorizedAccessException("User authentication required");

            var user = await _userRepository
                .Where(u => u.Id == userId.Value)
                .SingleOrDefaultAsync(cancellationToken);

            if (user == null)
                throw new UserNotFoundException(userId.Value);

            var languageIsActive = await _languageEntityRepository.AsQueryable()
                .FirstOrDefaultAsync(l => l.Code == request.LanguageCode && l.IsActive,
                    cancellationToken: cancellationToken);
            if (languageIsActive == null)
                throw new LanguageNotFoundException(request.LanguageCode);
                
            var values = _valueRepository
                .Where(v => v.OwnerId == userId.Value)
                .Include(v => v.Translations)
                .ThenInclude(t => t.Language)
                .ToList();

            if(values.Count == 0)
                throw new TranslationNotFoundException(request.LanguageCode);
            List<string> existingTranslations = [];
            
            foreach (var value in values)
            {
                var translations = value.Translations;
                foreach (var translation in translations)
                {
                    if (translation.Language.Code == request.LanguageCode)
                    {
                        existingTranslations.Add(translation.TranslationValue);
                        continue;
                    }
                    Console.Write(1);
                    
                    //generate translation with AI
                    var generatedTranslation = "Translation generated by ai";
                    
                    var createdTranslation = new TranslationEntity(value.Id, generatedTranslation)
                    {
                        Language = languageIsActive
                    };
                    
                    await _translationRepository.AddAsync(createdTranslation, cancellationToken);

                    if (await _valueCacheService.IsValueCached(value.Id))
                    {
                        await _valueCacheService.DeleteValueTranslationsAsync(value.Id);
                        var updatedTranslations = await _translationRepository
                            .Where(t => t.Value.Id == value.Id)
                            .AsNoTracking()
                            .Include(t => t.Language)
                            .Select(t => new TranslationDto(
                                value.Key,
                                t.TranslationValue,
                                value.Id,
                                t.Language.Code
                            ))
                            .ToListAsync(cancellationToken);

                        await _valueCacheService.SetTranslationsAsync(value.Id, value.Key, updatedTranslations);
                    }
                }
            }

            await _translationRepository.SaveChangesAsync(cancellationToken);
        }
    }
}